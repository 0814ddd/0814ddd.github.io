<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>物理接物挑战</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#F59E0B',  // 改为黄色系
            secondary: '#EAB308',
            accent: '#FCD34D',
            dark: '#1E293B',
            light: '#F8FAFC'
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
        },
      }
    }
  </script>
  <style type="text/tailwindcss">
    @layer utilities {
      /* 修改阴影颜色\ */
      .game-shadow {
        box-shadow: 0 0 15px rgba(245, 159, 11, 0);
      }
      /* 添加平滑过渡 */
      .player-transition {
        transition: left 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      }
      /* 原有的其他样式保持不变 */
      .content-auto {
        content-visibility: auto;
      }
      .item-shadow {
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      }
      .btn-hover {
        transition: all 0.3s ease;
      }
      .btn-hover:hover {
        transform: translateY(-2px);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }
      .floating {
        animation: float 3s ease-in-out infinite;
      }
      @keyframes float {
        0% { transform: translateY(0px); }
        50% { transform: translateY(-10px); }
        100% { transform: translateY(0px); }
      }
      .falling {
        animation: fall linear forwards;
      }
      @keyframes fall {
        to { transform: translateY(calc(100vh - 120px)); }
      }
      .scale-in {
        animation: scaleIn 0.3s ease-out forwards;
      }
      @keyframes scaleIn {
        from { transform: scale(0.8); opacity: 0; }
        to { transform: scale(1); opacity: 1; }
      }
      .shake {
        animation: shake 0.5s ease-in-out;
      }
      @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
      }
      .fade-out {
        animation: fadeOut 0.5s ease-out forwards;
      }
      @keyframes fadeOut {
        from { opacity: 1; }
        to { opacity: 0; }
      }
      .score-popup {
        animation: scorePopup 1s ease-out forwards;
      }
      @keyframes scorePopup {
        0% { transform: translateY(0); opacity: 1; }
        100% { transform: translateY(-30px); opacity: 0; }
      }
    }
    #player img {
      pointer-events: none; /* 使图片不响应鼠标事件 */
      user-select: none;    /* 防止图片被选中 */
    }
    .falling-item img {
      pointer-events: none;  /* 禁止触发鼠标事件 */
      user-select: none;     /* 禁止文本选中 */
      -webkit-user-drag: none; /* 禁止拖动（Safari兼容） */
    }
  </style>
</head>
<body class="bg-gradient-to-br from-yellow-50 to-amber-100 min-h-screen font-sans text-dark overflow-hidden">
  <!-- 游戏容器 -->
  <div id="game-container" class="relative w-full h-screen">
    <!-- 游戏开始界面 -->
    <div id="start-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-gradient-to-br from-primary/95 to-accent/95 z-50">
      <h1 class="text-[clamp(2.5rem,5vw,4rem)] font-bold text-white mb-6 tracking-tight floating">物理接物挑战</h1>
      <p class="text-white/90 text-[clamp(1rem,2vw,1.25rem)] mb-10 max-w-md text-center">
        通过鼠标拖动控制底部的容器，接住掉落的物理知识宝箱！<br>
        每接到一个宝箱将随机出现一道初中物理选择题，<br>
        答对获得1分，答错扣1分，时间结束后查看最终得分！
      </p>
      <div class="flex flex-col sm:flex-row gap-4 mb-8">
        <div class="bg-white/20 backdrop-blur-sm rounded-xl p-4 flex items-center gap-3">
          <i class="fa-solid fa-clock text-white text-xl"></i>
          <div>
            <p class="text-white font-medium">游戏时间</p>
            <p class="text-white/80 text-sm">60秒</p>
          </div>
        </div>
        <div class="bg-white/20 backdrop-blur-sm rounded-xl p-4 flex items-center gap-3">
          <i class="fa-solid fa-question-circle text-white text-xl"></i>
          <div>
            <p class="text-white font-medium">题目类型</p>
            <p class="text-white/80 text-sm">初中物理选择题</p>
          </div>
        </div>
        <div class="bg-white/20 backdrop-blur-sm rounded-xl p-4 flex items-center gap-3">
          <i class="fa-solid fa-mouse-pointer text-white text-xl"></i>
          <div>
            <p class="text-white font-medium">控制方式</p>
            <p class="text-white/80 text-sm">鼠标拖动控制</p>
          </div>
        </div>
      </div>
      <button id="start-btn" class="bg-secondary hover:bg-secondary/90 text-white font-bold py-4 px-8 rounded-full text-xl shadow-lg btn-hover">
        开始游戏 <i class="fa-solid fa-play ml-2"></i>
      </button>
    </div>

    <!-- 游戏界面 -->
    <div id="game-screen" class="absolute inset-0 hidden">
      <!-- 游戏背景 -->
      <div class="absolute inset-0 bg-gradient-to-br from-yellow-50 to-amber-100">
        <!-- 修改装饰公式颜色 -->
        <div class="absolute top-10 left-10 text-yellow-200 text-3xl opacity-50">E=mc²</div>
        <div class="absolute top-20 right-20 text-yellow-200 text-2xl opacity-40">F=ma</div>
        <div class="absolute bottom-20 left-1/3 text-yellow-200 text-xl opacity-30">v=λf</div>
        <div class="absolute bottom-30 right-1/4 text-yellow-200 text-2xl opacity-40">P=IV</div>
      </div>

      <!-- 游戏状态面板 -->
      <div class="absolute top-0 left-0 right-0 bg-white/80 backdrop-blur-md shadow-md z-10 py-3 px-6 flex justify-between items-center">
        <div class="flex items-center gap-3">
          <div class="bg-primary text-white p-2 rounded-lg">
            <i class="fa-solid fa-clock"></i>
          </div>
          <div>
            <p class="text-xs text-gray-500">剩余时间</p>
            <p id="timer" class="text-xl font-bold">60s</p>
          </div>
        </div>
        <div class="flex items-center gap-3">
          <div class="bg-secondary text-white p-2 rounded-lg">
            <i class="fa-solid fa-star"></i>
          </div>
          <div>
            <p class="text-xs text-gray-500">当前分数</p>
            <p id="score" class="text-xl font-bold">0</p>
          </div>
        </div>
        <button id="pause-btn" class="bg-gray-200 hover:bg-gray-300 p-2 rounded-lg transition-colors">
          <i class="fa-solid fa-pause"></i>
        </button>
      </div>

      <!-- 游戏区域 -->
      <div id="play-area" class="absolute inset-0 top-16 overflow-hidden">
        <!-- 玩家控制的容器，添加平滑过渡 -->
        <div id="player" class="player-transition absolute bottom-10 left-1/2 transform -translate-x-1/2 w-24 h-16 bg-primary rounded-lg flex items-center justify-center game-shadow"style="background: rgba(255, 160, 0, 0);">
          <img src="1.png" alt="玩家容器" class="w-12 h-12 object-contain"draggable="false">
        </div>

        <!-- 分数提示 -->
        <div id="score-popup" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-3xl font-bold opacity-0 pointer-events-none"></div>
      </div>

      <!-- 游戏暂停界面 -->
      <div id="pause-screen" class="absolute inset-0 bg-dark/70 backdrop-blur-sm flex flex-col items-center justify-center z-20 hidden">
        <h2 class="text-white text-3xl font-bold mb-8">游戏暂停</h2>
        <button id="resume-btn" class="bg-primary hover:bg-primary/90 text-white font-bold py-3 px-6 rounded-full mb-4 btn-hover">
          继续游戏 <i class="fa-solid fa-play ml-2"></i>
        </button>
        <button id="restart-btn" class="bg-secondary hover:bg-secondary/90 text-white font-bold py-3 px-6 rounded-full mb-4 btn-hover">
          重新开始 <i class="fa-solid fa-refresh ml-2"></i>
        </button>
        <button id="exit-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-full btn-hover">
          退出游戏 <i class="fa-solid fa-sign-out ml-2"></i>
        </button>
      </div>

      <!-- 问题弹窗 -->
      <div id="question-modal" class="absolute inset-0 bg-dark/70 backdrop-blur-sm flex items-center justify-center z-30 hidden">
        <div class="bg-white rounded-2xl shadow-2xl p-6 max-w-md w-full mx-4 scale-in">
          <h3 class="text-2xl font-bold text-primary mb-4">物理小测验</h3>
          <p id="question-text" class="text-lg mb-6 font-medium">题目将在这里显示</p>
          <div id="options-container" class="space-y-3 mb-6">
            <!-- 选项将通过JS动态生成 -->
          </div>
          <div class="flex justify-between">
            <div>
              <p class="text-xs text-gray-500">剩余时间</p>
              <p id="modal-timer" class="text-lg font-bold">60s</p>
            </div>
            <div>
              <p class="text-xs text-gray-500">当前分数</p>
              <p id="modal-score" class="text-lg font-bold">0</p>
            </div>
          </div>
        </div>
      </div>

      <!-- 限制动画效果 -->
      <div id="restriction-overlay" class="absolute inset-0 bg-red-500/10 backdrop-blur-sm flex items-center justify-center z-20 hidden">
        <div class="text-5xl font-bold text-red-600" id="restriction-counter">3</div>
      </div>
    </div>

    <!-- 游戏结束界面 -->
    <div id="game-over-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-gradient-to-br from-dark to-gray-800 z-50 hidden">
      <h2 class="text-[clamp(2rem,4vw,3rem)] font-bold text-white mb-4">游戏结束!</h2>
      <div class="bg-white/10 backdrop-blur-md rounded-2xl p-8 mb-8 text-center w-full max-w-md mx-4">
        <p class="text-white/80 text-xl mb-2">最终得分</p>
        <div class="text-5xl font-bold text-secondary mb-6" id="final-score">0</div>
        <div class="flex justify-center gap-4 mb-6">
          <div class="bg-white/10 rounded-xl p-4">
            <p class="text-white/70 text-sm">正确题数</p>
            <p class="text-white text-2xl font-bold" id="correct-answers">0</p>
          </div>
          <div class="bg-white/10 rounded-xl p-4">
            <p class="text-white/70 text-sm">错误题数</p>
            <p class="text-white text-2xl font-bold" id="wrong-answers">0</p>
          </div>
          <div class="bg-white/10 rounded-xl p-4">
            <p class="text-white/70 text-sm">准确率</p>
            <p class="text-white text-2xl font-bold" id="accuracy">0%</p>
          </div>
        </div>
        <div class="text-white/70 mb-4">
          <p id="performance-message" class="text-lg">继续加油！</p>
        </div>
      </div>
      <div class="flex flex-col sm:flex-row gap-4">
        <button id="play-again-btn" class="bg-primary hover:bg-primary/90 text-white font-bold py-3 px-8 rounded-full text-lg shadow-lg btn-hover">
          再玩一次 <i class="fa-solid fa-refresh ml-2"></i>
        </button>
        <button id="exit-game-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-8 rounded-full text-lg shadow-lg btn-hover">
          退出游戏 <i class="fa-solid fa-home ml-2"></i>
        </button>
      </div>
    </div>
  </div>

  <script>
    // 游戏配置
    const GAME_CONFIG = {
      playerSpeed: 8,  // 提升移动速度
      itemSpeed: 6,    // 下落速度加倍
      itemSpawnInterval: 2000,
      gameTime: 60,    // 秒
      restrictionTime: 3, // 秒
      itemSize: 40,
      playerWidth: 96,
      playerHeight: 64
    };

    // 添加鼠标拖动相关变量
    let isDragging = false;
    let startX = 0;
    let initialLeft = 0;

    // 物理题库
    const PHYSICS_QUESTIONS = [
      {
        question: "下列哪种现象属于光的折射？",
        options: ["水中倒影", "小孔成像", "海市蜃楼", "影子"],
        answer: 2,
        explanation: "海市蜃楼是由于光线在不同密度的空气中折射而形成的虚像。"
      },
      {
        question: "声音在下列哪种介质中传播速度最快？",
        options: ["空气", "水", "钢铁", "真空"],
        answer: 2,
        explanation: "声音的传播速度与介质密度有关，固体密度最大，所以在钢铁中传播最快。"
      },
      {
        question: "下列哪种力属于非接触力？",
        options: ["摩擦力", "弹力", "重力", "拉力"],
        answer: 2,
        explanation: "重力是地球对物体的吸引作用，不需要接触即可产生。"
      },
      {
        question: "当物体受到平衡力作用时，它将保持：",
        options: ["静止状态", "匀速直线运动", "加速运动", "可能静止或匀速直线运动"],
        answer: 3,
        explanation: "根据牛顿第一定律，物体在平衡力作用下将保持静止或匀速直线运动状态。"
      },
      {
        question: "下列哪种现象是利用了大气压的作用？",
        options: ["用吸管吸饮料", "潜水艇上浮下沉", "热气球升空", "火箭发射"],
        answer: 0,
        explanation: "用吸管吸饮料时，吸管内气压减小，大气压将饮料压入吸管。"
      },
      {
        question: "下列哪种电器是利用电流的热效应工作的？",
        options: ["电视机", "电风扇", "电熨斗", "洗衣机"],
        answer: 2,
        explanation: "电熨斗工作时，将电能转化为热能，利用了电流的热效应。"
      },
      {
        question: "下列哪种情况属于省力杠杆？",
        options: ["镊子", "钓鱼竿", "羊角锤拔钉子", "扫帚"],
        answer: 2,
        explanation: "羊角锤拔钉子时，动力臂大于阻力臂，属于省力杠杆。"
      },
      {
        question: "水的比热容较大，这一特性在生活中有很多应用，下列不属于这一应用的是：",
        options: ["汽车发动机用水冷却", "暖气中用水做传热介质", "夏天在室内洒水降温", "培育水稻秧苗时，傍晚向秧田里灌水"],
        answer: 2,
        explanation: "夏天在室内洒水降温是利用水蒸发吸热，与比热容无关。"
      },
      {
        question: "下列哪种现象是由于惯性造成的？",
        options: ["汽车急刹车时，乘客向前倾倒", "苹果从树上落下", "用手拍打衣服，灰尘脱落", "跳远运动员助跑一段距离后起跳"],
        answer: 0,
        explanation: "汽车急刹车时，乘客由于惯性要保持原来的运动状态，所以向前倾倒。"
      },
      {
        question: "下列关于凸透镜成像的说法中，正确的是：",
        options: ["成实像时，物距越大，像距越大", "成虚像时，物距越大，像距越大", "成实像时，像一定是倒立的", "成虚像时，像一定是放大的"],
        answer: 2,
        explanation: "凸透镜成实像时，物像异侧，像一定是倒立的。"
      }
    ];

    // 游戏状态
    const gameState = {
      score: 0,
      timeRemaining: GAME_CONFIG.gameTime,
      isPlaying: false,
      isPaused: false,
      isRestricted: false,
      isAnswering: false, // 新增答题锁定状态
      timerInterval: null,
      spawnInterval: null, // 将spawnInterval移入gameState统一管理
      items: [],
      correctAnswers: 0,
      wrongAnswers: 0,
      currentQuestion: null
    };

    // DOM 元素
    const startScreen = document.getElementById('start-screen');
    const gameScreen = document.getElementById('game-screen');
    const pauseScreen = document.getElementById('pause-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const questionModal = document.getElementById('question-modal');
    const restrictionOverlay = document.getElementById('restriction-overlay');
    const startBtn = document.getElementById('start-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const resumeBtn = document.getElementById('resume-btn');
    const restartBtn = document.getElementById('restart-btn');
    const exitBtn = document.getElementById('exit-btn');
    const playAgainBtn = document.getElementById('play-again-btn');
    const exitGameBtn = document.getElementById('exit-game-btn');
    const player = document.getElementById('player');
    const timerEl = document.getElementById('timer');
    const scoreEl = document.getElementById('score');
    const scorePopup = document.getElementById('score-popup');
    const finalScoreEl = document.getElementById('final-score');
    const correctAnswersEl = document.getElementById('correct-answers');
    const wrongAnswersEl = document.getElementById('wrong-answers');
    const accuracyEl = document.getElementById('accuracy');
    const performanceMessageEl = document.getElementById('performance-message');
    const questionText = document.getElementById('question-text');
    const optionsContainer = document.getElementById('options-container');
    const modalTimer = document.getElementById('modal-timer');
    const modalScore = document.getElementById('modal-score');
    const restrictionCounter = document.getElementById('restriction-counter');
    const playArea = document.getElementById('play-area');

    // 初始化事件监听
    function initEventListeners() {
      // 开始游戏
      startBtn.addEventListener('click', startGame);
      
      // 暂停游戏
      pauseBtn.addEventListener('click', pauseGame);
      resumeBtn.addEventListener('click', resumeGame);
      
      // 重新开始
      restartBtn.addEventListener('click', restartGame);
      playAgainBtn.addEventListener('click', restartGame);
      
      // 退出游戏
      exitBtn.addEventListener('click', exitGame);
      exitGameBtn.addEventListener('click', exitGame);
      
      // 鼠标拖动控制
      player.addEventListener('mousedown', startDrag);
      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', endDrag);
    }

    // 鼠标拖动处理函数
    function startDrag(e) {
      if (!gameState.isPlaying || gameState.isRestricted || gameState.isAnswering) return;
      isDragging = true;
      // 获取父容器坐标信息
      const playAreaRect = playArea.getBoundingClientRect();
      // 计算鼠标点击点相对于父容器的水平坐标
      startX = e.clientX - playAreaRect.left; 
      
      // 获取当前容器的相对位置（像素值）
      initialLeft = parseFloat(getComputedStyle(player).left);
      player.style.transition = 'none';
    }

    function drag(e) {
      if (!isDragging) return;
       // 获取父容器坐标信息
      const playAreaRect = playArea.getBoundingClientRect();
        // 计算鼠标当前位置相对于父容器的坐标
      const currentX = e.clientX - playAreaRect.left;
        
        // 计算新位置（基于初始相对位置）
      let newLeft = initialLeft + (currentX - startX);
        
        // 限制移动范围（父容器宽度 - 容器自身宽度）
      const maxLeft = playAreaRect.width - player.offsetWidth;
      newLeft = Math.max(0, Math.min(newLeft, maxLeft));
        
        // 使用像素单位设置位置
      player.style.left = `${newLeft}px`;
    }

    function endDrag() {
      isDragging = false;
      player.style.transition = 'left 0.15s cubic-bezier(0.4, 0, 0.2, 1)';
    }

    // 开始游戏
    function startGame() {
      startScreen.classList.add('hidden');
      gameScreen.classList.remove('hidden');
      
      gameState.isPlaying = true;
      gameState.isPaused = false;
      gameState.isRestricted = false;
      gameState.isAnswering = false;
      gameState.score = 0;
      gameState.timeRemaining = GAME_CONFIG.gameTime;
      gameState.correctAnswers = 0;
      gameState.wrongAnswers = 0;
      
      updateScore();
      updateTimer();
      
      // 重置玩家位置
      player.style.left = '50%';
      
      // 开始游戏循环
      gameLoop();
      
      // 开始生成物品
      gameState.spawnInterval = setInterval(spawnItem, GAME_CONFIG.itemSpawnInterval);
      
      // 开始倒计时
      gameState.timerInterval = setInterval(updateGameTime, 1000);
    }

    // 暂停游戏
    function pauseGame() {
      if (!gameState.isPlaying || gameState.isPaused) return;
      
      gameState.isPaused = true;
      pauseScreen.classList.remove('hidden');
    }

    // 恢复游戏
    function resumeGame() {
      if (!gameState.isPlaying || !gameState.isPaused) return;
      
      gameState.isPaused = false;
      pauseScreen.classList.add('hidden');
    }

    // 重新开始游戏
    function restartGame() {
      gameState.isAnswering = false;
      isDragging = false;
      
      // 清除所有定时器和物品
      clearInterval(gameState.timerInterval);
      clearInterval(gameState.spawnInterval);
      clearItems();
      
      // 隐藏所有屏幕，显示开始屏幕
      pauseScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      questionModal.classList.add('hidden');
      restrictionOverlay.classList.add('hidden');
      
      startGame();
    }

    // 退出游戏
    function exitGame() {
      // 清除所有定时器和物品
      clearInterval(gameState.timerInterval);
      clearInterval(gameState.spawnInterval);
      clearItems();
      
      // 隐藏所有屏幕，显示开始屏幕
      gameScreen.classList.add('hidden');
      pauseScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      questionModal.classList.add('hidden');
      restrictionOverlay.classList.add('hidden');
      startScreen.classList.remove('hidden');
      
      gameState.isPlaying = false;
    }

    // 清除所有物品
    function clearItems() {
      const items = document.querySelectorAll('.falling-item');
      items.forEach(item => item.remove());
      gameState.items = [];
    }

    // 更新游戏时间
    function updateGameTime() {
      if (gameState.isPaused) return;
      
      gameState.timeRemaining--;
      updateTimer();
      
      if (gameState.timeRemaining <= 0) {
        endGame();
      }
    }

    // 更新计时器显示
    function updateTimer() {
      timerEl.textContent = `${gameState.timeRemaining}s`;
      modalTimer.textContent = `${gameState.timeRemaining}s`;
    }

    // 更新分数显示
    function updateScore() {
      scoreEl.textContent = gameState.score;
      modalScore.textContent = gameState.score;
    }

    // 生成物品
    function spawnItem() {
      if (!gameState.isPlaying || gameState.isPaused || gameState.isAnswering) return;
      
      const playAreaWidth = playArea.clientWidth;
      const left = Math.random() * (playAreaWidth - GAME_CONFIG.itemSize);
      
      const item = document.createElement('div');
      item.className = 'falling-item absolute w-12 h-12 bg-transparent rounded-lg flex items-center justify-center scale-in';
      item.style.left = `${left}px`;
      item.style.top = '-60px'; // 起始位置在屏幕外

      // 新增动态图标逻辑
      const icons = ['physics1.png', 'physics2.png', 'physics3.png']; // 图片命名规范
      const randomIcon = icons[Math.floor(Math.random() * icons.length)];

      item.innerHTML = `
        <img src="${randomIcon}" 
            alt="物理题目" 
            class="w-10 h-10 object-contain pointer-events-none select-none"
            draggable="false">
      `;
      
      // 计算下落时间
      const playAreaHeight = playArea.clientHeight;
      const fallDuration = playAreaHeight / GAME_CONFIG.itemSpeed / 70; // 速度加倍
      
      item.style.animation = `fall ${fallDuration}s linear forwards`;
      
      playArea.appendChild(item);
      
      // 添加到物品数组
      gameState.items.push({
        element: item,
        left: left,
        top: -GAME_CONFIG.itemSize,
        width: GAME_CONFIG.itemSize,
        height: GAME_CONFIG.itemSize,
        fallDuration: fallDuration
      });
      
      // 设置定时器，当物品落下后移除
      setTimeout(() => {
        if (item.parentNode === playArea) {
          removeItem(item);
        }
      }, fallDuration * 1000);
    }

    // 移除物品
    function removeItem(item) {
      item.classList.add('fade-out');
      
      setTimeout(() => {
        if (item.parentNode === playArea) {
          playArea.removeChild(item);
        }
        
        // 从数组中移除
        gameState.items = gameState.items.filter(i => i.element !== item);
      }, 300);
    }

    // 显示问题弹窗
    function showQuestionModal() {
      gameState.isAnswering = true;
      clearInterval(gameState.spawnInterval); // 停止生成新物品
      
      // 随机选择一个问题
      const randomIndex = Math.floor(Math.random() * PHYSICS_QUESTIONS.length);
      gameState.currentQuestion = PHYSICS_QUESTIONS[randomIndex];
      
      // 更新问题文本
      questionText.textContent = gameState.currentQuestion.question;
      
      // 清空选项容器
      optionsContainer.innerHTML = '';
      
      // 添加选项按钮
      gameState.currentQuestion.options.forEach((option, index) => {
        const button = document.createElement('button');
        button.className = 'w-full text-left px-4 py-3 rounded-lg border border-gray-200 hover:border-primary hover:bg-primary/5 transition-all duration-200 btn-hover';
        button.innerHTML = `
          <span class="inline-flex items-center justify-center w-6 h-6 rounded-full bg-primary/10 text-primary mr-3">
            ${String.fromCharCode(65 + index)}
          </span>
          ${option}
        `;
        
        button.addEventListener('click', () => checkAnswer(index));
        optionsContainer.appendChild(button);
      });
      
      // 显示问题弹窗
      questionModal.classList.remove('hidden');
      player.style.opacity = '0.5'; // 降低透明度表示锁定
    }

    // 检查答案
    function checkAnswer(selectedIndex) {
      questionModal.classList.add('hidden');
      player.style.opacity = '1'; // 恢复透明度
      
      if (selectedIndex === gameState.currentQuestion.answer) {
        // 回答正确
        gameState.score++;
        gameState.correctAnswers++;
        showScorePopup('+1', 'text-green-600');
        
        // 显示正确提示动画
        showFeedbackAnimation(true);
      } else {
        // 回答错误
        gameState.score--;
        gameState.wrongAnswers++;
        showScorePopup('-1', 'text-red-600');
        
        // 显示错误提示动画并限制玩家控制
        showFeedbackAnimation(false);
        restrictPlayer();
      }
      
      updateScore();
      
      //答题结束后恢复生成新物品
      gameState.isAnswering = false;
      gameState.spawnInterval = setInterval(spawnItem, GAME_CONFIG.itemSpawnInterval);
    }

    // 显示分数弹窗
    function showScorePopup(text, className) {
      scorePopup.textContent = text;
      scorePopup.className = `absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-3xl font-bold opacity-0 pointer-events-none ${className} score-popup`;
      
      setTimeout(() => {
        scorePopup.style.opacity = '1';
      }, 10);
      
      setTimeout(() => {
        scorePopup.style.opacity = '0';
      }, 1000);
    }

    // 显示反馈动画
    function showFeedbackAnimation(isCorrect) {
      const feedback = document.createElement('div');
      feedback.className = `absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-4xl font-bold ${isCorrect ? 'text-green-500' : 'text-red-500'} scale-in`;
      feedback.textContent = isCorrect ? '✓ 正确!' : '✗ 错误!';
      
      playArea.appendChild(feedback);
      
      setTimeout(() => {
        feedback.classList.add('fade-out');
        setTimeout(() => {
          if (feedback.parentNode === playArea) {
            playArea.removeChild(feedback);
          }
        }, 300);
      }, 1000);
    }

    // 限制玩家控制
    function restrictPlayer() {
      gameState.isRestricted = true;
      restrictionOverlay.classList.remove('hidden');
      
      let counter = GAME_CONFIG.restrictionTime;
      restrictionCounter.textContent = counter;
      
      const counterInterval = setInterval(() => {
        counter--;
        restrictionCounter.textContent = counter;
        
        if (counter <= 0) {
          clearInterval(counterInterval);
          gameState.isRestricted = false;
          restrictionOverlay.classList.add('hidden');
        }
      }, 1000);
    }

    // 游戏主循环
    function gameLoop() {
      if (!gameState.isPlaying || gameState.isPaused) return;
      
      // 更新玩家位置（如果需要的话）
      updatePlayerPosition();
      
      // 检测碰撞
      checkCollisions();
      
      // 继续游戏循环
      requestAnimationFrame(gameLoop);
    }

    // 更新玩家位置
    function updatePlayerPosition() {
      if (gameState.isRestricted || gameState.isAnswering) return;
    }

    // 检测碰撞
    function checkCollisions() {
      if (!gameState.isPlaying || 
          gameState.isPaused || 
          gameState.isRestricted || 
          gameState.isAnswering || 
          isDragging) return; // 添加拖动状态检查
      
      const playerRect = player.getBoundingClientRect();
      
      gameState.items.forEach(item => {
        const itemRect = item.element.getBoundingClientRect();
        
        // 检查碰撞
        if (
          itemRect.bottom >= playerRect.top &&
          itemRect.top <= playerRect.bottom &&
          itemRect.right >= playerRect.left &&
          itemRect.left <= playerRect.right
        ) {
          // 发生碰撞
          removeItem(item.element);
          
          // 显示问题弹窗
          showQuestionModal();
        }
      });
    }

    // 结束游戏
    function endGame() {
      // 清除所有定时器
      clearInterval(gameState.timerInterval);
      clearInterval(gameState.spawnInterval);
      
      // 隐藏所有弹窗
      questionModal.classList.add('hidden');
      pauseScreen.classList.add('hidden');
      
      // 显示游戏结束屏幕
      gameOverScreen.classList.remove('hidden');
      
      // 更新游戏结束统计信息
      finalScoreEl.textContent = gameState.score;
      correctAnswersEl.textContent = gameState.correctAnswers;
      wrongAnswersEl.textContent = gameState.wrongAnswers;
      
      // 计算准确率
      const totalAnswers = gameState.correctAnswers + gameState.wrongAnswers;
      const accuracy = totalAnswers > 0 ? Math.round((gameState.correctAnswers / totalAnswers) * 100) : 0;
      accuracyEl.textContent = `${accuracy}%`;
      
      // 根据得分显示不同的消息
      if (gameState.score > 5) {
        performanceMessageEl.textContent = "太棒了！你的物理知识很扎实！";
      } else if (gameState.score > 0) {
        performanceMessageEl.textContent = "做得不错，继续加油！";
      } else {
        performanceMessageEl.textContent = "别灰心，再试一次，你会进步的！";
      }
      
      // 清除所有物品
      clearItems();
      
      // 重置游戏状态
      gameState.isPlaying = false;
    }

    // 初始化游戏
    function initGame() {
      initEventListeners();
    }

    // 启动游戏
    window.addEventListener('load', initGame);
  </script>
</body>
</html>